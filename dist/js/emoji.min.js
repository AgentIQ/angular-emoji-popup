/*! Angular Emoji 1.1.0 2017-04-24 */
/* angular-meditor directive
 */

/**
 * angular-strap
 * @version v2.3.12 - 2017-01-26
 * @link http://mgcrea.github.io/angular-strap
 * @author Olivier Louvignes <olivier@mg-crea.com> (https://github.com/mgcrea)
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */


angular.module('colorpicker.module', [])
  .factory('Helper', function () {
    return {
      closestSlider: function (elem) {
        var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;
        if (matchesSelector.bind(elem)('I')) {
          return elem.parentNode;
        }
        return elem;
      },
      getOffset: function (elem) {
        var
          x = 0,
          y = 0;
        while (elem && !isNaN(elem.offsetLeft) && !isNaN(elem.offsetTop)) {
          x += elem.offsetLeft;
          y += elem.offsetTop;
          elem = elem.offsetParent;
        }
        return {
          top: y,
          left: x
        };
      },
      // a set of RE's that can match strings and generate color tuples. https://github.com/jquery/jquery-color/
      stringParsers: [
        {
          re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
          parse: function (execResult) {
            return [
              execResult[1],
              execResult[2],
              execResult[3],
              execResult[4]
            ];
          }
        },
        {
          re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
          parse: function (execResult) {
            return [
              2.55 * execResult[1],
              2.55 * execResult[2],
              2.55 * execResult[3],
              execResult[4]
            ];
          }
        },
        {
          re: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
          parse: function (execResult) {
            return [
              parseInt(execResult[1], 16),
              parseInt(execResult[2], 16),
              parseInt(execResult[3], 16)
            ];
          }
        },
        {
          re: /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/,
          parse: function (execResult) {
            return [
              parseInt(execResult[1] + execResult[1], 16),
              parseInt(execResult[2] + execResult[2], 16),
              parseInt(execResult[3] + execResult[3], 16)
            ];
          }
        }
      ]
    };
  })
  .factory('Color', ['Helper', function (Helper) {
    return {
      value: {
        h: 1,
        s: 1,
        b: 1,
        a: 1
      },
      // translate a format from Color object to a string
      'rgb': function () {
        var rgb = this.toRGB();
        return 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
      },
      'rgba': function () {
        var rgb = this.toRGB();
        return 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + rgb.a + ')';
      },
      'hex': function () {
        return this.toHex();
      },

      // HSBtoRGB from RaphaelJS
      RGBtoHSB: function (r, g, b, a) {
        r /= 255;
        g /= 255;
        b /= 255;

        var H, S, V, C;
        V = Math.max(r, g, b);
        C = V - Math.min(r, g, b);
        H = (C === 0 ? null :
          V == r ? (g - b) / C :
            V == g ? (b - r) / C + 2 :
              (r - g) / C + 4
        );
        H = ((H + 360) % 6) * 60 / 360;
        S = C === 0 ? 0 : C / V;
        return { h: H || 1, s: S, b: V, a: a || 1 };
      },

      HueToRGB: function (p, q, h) {
        if (h < 0)
          h += 1;
        else if (h > 1)
          h -= 1;

        if ((h * 6) < 1)
          return p + (q - p) * h * 6;
        else if ((h * 2) < 1)
          return q;
        else if ((h * 3) < 2)
          return p + (q - p) * ((2 / 3) - h) * 6;
        else
          return p;
      },

      //parse a string to HSB
      setColor: function (val) {
        val = val.toLowerCase();
        for (var key in Helper.stringParsers) {
          var parser = Helper.stringParsers[key];
          var match = parser.re.exec(val),
            values = match && parser.parse(match),
            space = parser.space || 'rgba';
          if (values) {
            this.value = this.RGBtoHSB.apply(null, values);
            return false;
          }
        }
      },

      setHue: function (h) {
        this.value.h = 1 - h;
      },

      setSaturation: function (s) {
        this.value.s = s;
      },

      setLightness: function (b) {
        this.value.b = 1 - b;
      },

      setAlpha: function (a) {
        this.value.a = parseInt((1 - a) * 100, 10) / 100;
      },

      // HSBtoRGB from RaphaelJS
      // https://github.com/DmitryBaranovskiy/raphael/
      toRGB: function (h, s, b, a) {
        if (!h) {
          h = this.value.h;
          s = this.value.s;
          b = this.value.b;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = b * s;
        X = C * (1 - Math.abs(h % 2 - 1));
        R = G = B = b - C;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return {
          r: Math.round(R * 255),
          g: Math.round(G * 255),
          b: Math.round(B * 255),
          a: a || this.value.a
        };
      },

      toHex: function (h, s, b, a) {
        var rgb = this.toRGB(h, s, b, a);
        return '#' + ((1 << 24) | (parseInt(rgb.r, 10) << 16) | (parseInt(rgb.g, 10) << 8) | parseInt(rgb.b, 10)).toString(16).substr(1);
      }
    };
  }])
  .factory('Slider', ['Helper', function (Helper) {
    var
      slider = {
        maxLeft: 0,
        maxTop: 0,
        callLeft: null,
        callTop: null,
        knob: {
          top: 0,
          left: 0
        }
      },
      pointer = {};

    return {
      getSlider: function () {
        return slider;
      },
      getLeftPosition: function (event) {
        return Math.max(0, Math.min(slider.maxLeft, slider.left + ((event.pageX || pointer.left) - pointer.left)));
      },
      getTopPosition: function (event) {
        return Math.max(0, Math.min(slider.maxTop, slider.top + ((event.pageY || pointer.top) - pointer.top)));
      },
      setSlider: function (event, fixedPosition) {
        var target = Helper.closestSlider(event.target);
        slider.knob = target.children[0].style;
        slider.left = event.pageX - Helper.getOffset(target).left;
        slider.top = event.pageY - Helper.getOffset(target).top;

        if (fixedPosition) {
          slider.left -= window.pageXOffset;
          slider.top -= window.pageYOffset;
        }
        pointer = {
          left: event.pageX,
          top: event.pageY
        };
      },
      setSaturation: function (event, fixedPosition) {
        slider = {
          maxLeft: 100,
          maxTop: 100,
          callLeft: 'setSaturation',
          callTop: 'setLightness'
        };
        this.setSlider(event, fixedPosition)
      },
      setHue: function (event, fixedPosition) {
        slider = {
          maxLeft: 0,
          maxTop: 100,
          callLeft: false,
          callTop: 'setHue'
        };
        this.setSlider(event, fixedPosition)
      },
      setAlpha: function (event, fixedPosition) {
        slider = {
          maxLeft: 0,
          maxTop: 100,
          callLeft: false,
          callTop: 'setAlpha'
        };
        this.setSlider(event, fixedPosition)
      },
      setKnob: function (top, left) {
        slider.knob.top = top + 'px';
        slider.knob.left = left + 'px';
      }
    };
  }])
  .directive('colorpicker', ['$document', '$compile', 'Color', 'Slider', 'Helper', function ($document, $compile, Color, Slider, Helper) {
    return {
      require: '?ngModel',
      restrict: 'A',
      link: function ($scope, elem, attrs, ngModel) {
        var
          template =
            '<div class="colorpicker f-dropdown">' +
            '<colorpicker-saturation><i></i></colorpicker-saturation>' +
            '<colorpicker-hue><i></i></colorpicker-hue>' +
            '<colorpicker-alpha><i></i></colorpicker-alpha>' +
            '<colorpicker-preview></colorpicker-preview>' +
            '<button class="tiny secondary button right">&times;</button>' +
            '</div>',
          colorpickerTemplate = angular.element(template),
          pickerColor = Color,
          sliderAlpha,
          sliderHue = colorpickerTemplate.find('colorpicker-hue'),
          sliderSaturation = colorpickerTemplate.find('colorpicker-saturation'),
          colorpickerPreview = colorpickerTemplate.find('colorpicker-preview'),
          pickerColorPointers = colorpickerTemplate.find('i'),
          thisFormat = attrs.colorpicker ? attrs.colorpicker : 'hex',
          fixedPosition = angular.isDefined(attrs.colorpickerFixedPosition) ? attrs.colorpickerFixedPosition : false,
          target = angular.isDefined(attrs.colorpickerParent) ? elem.parent() : angular.element(document.body);

        $compile(colorpickerTemplate)($scope);

        var bindMouseEvents = function () {
          $document.on('mousemove', mousemove);
          $document.on('mouseup', mouseup);
        };

        if (thisFormat === 'rgba') {
          colorpickerTemplate.addClass('alpha');
          sliderAlpha = colorpickerTemplate.find('colorpicker-alpha');
          sliderAlpha
            .on('click', function (event) {
              Slider.setAlpha(event, fixedPosition);
              mousemove(event);
            })
            .on('mousedown', function (event) {
              Slider.setAlpha(event, fixedPosition);
              bindMouseEvents();
            });
        }

        sliderHue
          .on('click', function (event) {
            Slider.setHue(event, fixedPosition);
            mousemove(event);
          })
          .on('mousedown', function (event) {
            Slider.setHue(event, fixedPosition);
            bindMouseEvents();
          });

        sliderSaturation
          .on('click', function (event) {
            Slider.setSaturation(event, fixedPosition);
            mousemove(event);
          })
          .on('mousedown', function (event) {
            Slider.setSaturation(event, fixedPosition);
            bindMouseEvents();
          });

        if (fixedPosition) {
          colorpickerTemplate.addClass('colorpicker-fixed-position');
        }

        target.append(colorpickerTemplate);

        if (ngModel) {
          ngModel.$render = function () {
            elem.val(ngModel.$viewValue);
          };
          $scope.$watch(attrs.ngModel, function () {
            update();
          });
        }

        elem.on('$destroy', function () {
          colorpickerTemplate.remove();
        });

        var previewColor = function () {
          try {
            colorpickerPreview.css('backgroundColor', pickerColor[thisFormat]());
          } catch (e) {
            colorpickerPreview.css('backgroundColor', pickerColor.toHex());
          }
          sliderSaturation.css('backgroundColor', pickerColor.toHex(pickerColor.value.h, 1, 1, 1));
          if (thisFormat === 'rgba') {
            sliderAlpha.css.backgroundColor = pickerColor.toHex();
          }
        };

        var mousemove = function (event) {
          var
            left = Slider.getLeftPosition(event),
            top = Slider.getTopPosition(event),
            slider = Slider.getSlider();

          Slider.setKnob(top, left);

          if (slider.callLeft) {
            pickerColor[slider.callLeft].call(pickerColor, left / 100);
          }
          if (slider.callTop) {
            pickerColor[slider.callTop].call(pickerColor, top / 100);
          }
          previewColor();
          var newColor = pickerColor[thisFormat]();
          elem.val(newColor);
          if (ngModel) {
            $scope.$apply(ngModel.$setViewValue(newColor));
          }
          return false;
        };

        var mouseup = function () {
          $document.off('mousemove', mousemove);
          $document.off('mouseup', mouseup);
        };

        var update = function () {
          pickerColor.setColor(elem.val());
          pickerColorPointers.eq(0).css({
            left: pickerColor.value.s * 100 + 'px',
            top: 100 - pickerColor.value.b * 100 + 'px'
          });
          pickerColorPointers.eq(1).css('top', 100 * (1 - pickerColor.value.h) + 'px');
          pickerColorPointers.eq(2).css('top', 100 * (1 - pickerColor.value.a) + 'px');
          previewColor();
        };

        var getColorpickerTemplatePosition = function () {
          var
            positionValue,
            positionOffset = Helper.getOffset(elem[0]);

          positionValue = {
            'top': positionOffset.top + elem[0].offsetHeight,
            'left': positionOffset.left
          };

          return {
            'top': positionValue.top + 'px',
            'left': positionValue.left + 'px'
          };
        };

        elem.on('click', function () {
          update();
          colorpickerTemplate
            .addClass('colorpicker-visible')
            .css(getColorpickerTemplatePosition());
        });

        colorpickerTemplate.on('mousedown', function (event) {
          event.stopPropagation();
          event.preventDefault();
        });

        var hideColorpickerTemplate = function () {
          if (colorpickerTemplate.hasClass('colorpicker-visible')) {
            colorpickerTemplate.removeClass('colorpicker-visible');
          }
        };

        colorpickerTemplate.find('button').on('click', function () {
          hideColorpickerTemplate();
        });

        $document.on('mousedown', function () {
          hideColorpickerTemplate();
        });
      }
    };
  }]);

angular.module('angular-meditor', ['colorpicker.module'])
  .directive('meditor', ['$timeout', function ($timeout) {
    //ng-click="SimpleAction('insertImage', 'http://cfis.github.io/free-image-ruby/cookbook/lena_rotate_ex_45_masked.png')"
    return {
      scope: {
        ngModel: '=',
        toolbarContainer: '@?'
      },
      require: '?ngModel',
      transclude: true,
      template: "\n<div class=\"angular-meditor\">\n  <div class=\"angular-meditor-toolbar\" style=\"top: {{ position.top }}px; left: {{ position.left }}px\" ng-class=\"{ 'angular-meditor-toolbar--show': model.showToolbar, 'angular-meditor-toolbar--bottom': position.below }\">\n    <ul ng-if=\"!imageInsert\">\n      <li>\n        <button type=\"button\" ng-click=\"SimpleAction('bold')\" class=\"meditor-button-bold\" ng-class=\"{ 'bold': 'meditor-button--active' }[styles.fontWeight]\">\n          B\n        </button>\n      </li>\n      <li>\n        <button type=\"button\" ng-click=\"SimpleAction('italic')\" class=\"meditor-button-italic\" ng-class=\"{ 'italic': 'meditor-button--active' }[styles.fontStyle]\">\n          I\n        </button>\n      </li>\n      <li>\n        <button type=\"button\" ng-click=\"SimpleAction('underline')\" class=\"meditor-button-underline\" ng-class=\"{ 'underline': 'meditor-button--active' }[styles.textDecoration]\">\n          U\n        </button>\n      </li>\n      <li>\n        <button type=\"button\" ng-click=\"SimpleAction('insertUnorderedList')\" class=\"meditor-button-list-ul\" ng-class=\"{ 'underline': 'meditor-button--active' }[styles.textDecoration]\">\n          <i class=\"fa fa-list-ul\"></i>\n        </button>\n      </li>\n      <li>\n        <button type=\"button\" ng-click=\"SimpleAction('insertOrderedList')\" class=\"meditor-button-list-ol\" ng-class=\"{ 'underline': 'meditor-button--active' }[styles.textDecoration]\">\n          <i class=\"fa fa-list-ol\"></i>\n        </button>\n      </li>\n      <li>\n        <button type=\"button\" ng-click=\"SimpleAction('formatBlock', 'blockquote')\" class=\"meditor-button-quote\" ng-class=\"{ 'underline': 'meditor-button--active' }[styles.textDecoration]\">\n          <i class=\"fa fa-quote-right\"></i>\n        </button>\n      </li>\n      <li>\n        <button type=\"button\" class=\"meditor-button-quote\" ng-class=\"{ 'underline': 'meditor-button--active' }[styles.textDecoration]\"\n          colorpicker ng-change=\"SimpleAction('foreColor', color)\" ng-model=\"color\">\n          <i class=\"fa fa-font\"></i>\n        </button>\n      </li>\n      <li>\n        <label class=\"meditor-select\">\n          <select ng-model=\"size\" ng-options=\"s.value as s.label for s in sizeOptions\" class=\"meditor-size-selector\"></select>\n        </label>\n      </li>\n      <li>\n        <label class=\"meditor-select\">\n          <select ng-model=\"family\" ng-options=\"s as s.label for s in familyOptions\" class=\"meditor-family-selector\"></select>\n        </label>\n      </li>\n      <li>\n        <button type=\"button\" insert-form insert-link=\"true\" class=\"meditor-button-link\" ng-class=\"{ 'underline': 'meditor-button--active' }[styles.textDecoration]\">\n          <i class=\"fa fa-link\"></i>\n        </button>\n      </li>\n      <li>\n        <button type=\"button\" insert-form class=\"meditor-button-link\" ng-class=\"{ 'underline': 'meditor-button--active' }[styles.textDecoration]\">\n          <i class=\"fa fa-picture-o\"></i>\n        </button>\n      </li>\n    </ul>\n  </div>\n  <div class=\"angular-meditor-content\" contenteditable meditor-contenteditable ng-model=\"model.ngModel\" ng-transclude></div>\n</div>\n",
      link: function (scope, element, attributes, ctrl) {

        scope.model = {
          ngModel: scope.ngModel,
          showToolbar: false
        };

        scope.imageLink = '';
        scope.imageInsert = false;

        scope.showInsertImage = function () {
          scope.$applyAsync(function () {
            alert(123);
            //scope.imageInsert = !scope.imageInsert;
          })
        }

        scope.link = {
          title: '',
          link: ''
        }

        scope.color = '';

        scope.$watch('model.ngModel', function () {
          $timeout(function () {
            scope.ngModel = scope.model.ngModel;
          });
        });

        // toolbar position
        scope.position = {
          top: 10,
          left: 10,
          below: false
        };

        // fontSize options
        scope.sizeOptions = [
          {
            label: '10',
            value: 1
          },
          {
            label: '13',
            value: 2
          },
          {
            label: '16',
            value: 3
          },
          {
            label: '18',
            value: 4
          },
          {
            label: '24',
            value: 5
          },
          {
            label: '32',
            value: 6
          },
          {
            label: '48',
            value: 7
          }
        ];
        scope.size = scope.sizeOptions[0].value;

        scope.familyOptions = [
          {
            label: 'Open Sans',
            value: 'Open Sans, sans-serif'
          },
          {
            label: 'Source Sans Pro',
            value: 'Source Sans Pro, sans-serif'
          },
          {
            label: 'Exo',
            value: 'Exo, sans-serif'
          },
          {
            label: 'Oswald',
            value: 'Oswald, sans-serif'
          },
          {
            label: 'Cardo',
            value: 'Cardo, serif'
          },
          {
            label: 'Vollkorn',
            value: 'Vollkorn, serif'
          },
          {
            label: 'Old Standard TT',
            value: 'Old Standard TT, serif'
          }
        ];
        scope.family = scope.familyOptions[0];

        // current styles of selected elements
        // used to highlight active buttons
        scope.styles = {};

        // tags generated by the editor
        // used to highlight active styles
        var generatedTags = {
          'b': '',
          'strong': '',
          'i': '',
          'em': '',
          'u': '',
          'blockquote': ''
        };

        // Remy Sharp's debounce
        // https://remysharp.com/2010/07/21/throttling-function-calls
        var debounce = function (fn, delay) {
          var timer = null;
          return function () {
            var context = this, args = arguments;
            clearTimeout(timer);
            timer = setTimeout(function () {
              fn.apply(context, args);
            }, delay);
          };
        };

        var $toolbar = angular.element(element[0].querySelector('.angular-meditor-toolbar'));
        var $content = angular.element(element[0].querySelector('.angular-meditor-content'));
        var $selects = angular.element(element[0].querySelector('select'));
        var $body = angular.element(document.querySelector(scope.toolbarContainer) || document.body);

        // position the toolbar above or below the selected text
        var setToolbarPosition = function () {
          var toolbarHeight = $toolbar[0].offsetHeight;
          var toolbarWidth = $toolbar[0].offsetWidth;
          var spacing = 5;
          var selection = window.getSelection();
          var range = selection.getRangeAt(0);
          var boundary = range.getBoundingClientRect();

          var topPosition = boundary.top;
          var leftPosition = boundary.left;

          // if there isn't enough space at the top, place it at the bottom
          // of the selection
          if (boundary.top < (toolbarHeight + spacing)) {
            scope.position.top = topPosition + boundary.height + spacing;
            // tell me if it's above or below the selection
            // used in the template to place the triangle above or below
            scope.position.below = true;
          } else {
            scope.position.top = topPosition - toolbarHeight - spacing;
            scope.position.below = false;
          }

          // center toolbar above selected text
          scope.position.left = leftPosition - (toolbarWidth / 2) + (boundary.width / 2);

          // cross-browser window scroll positions
          var scrollLeft = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
          var scrollTop = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;

          // add the scroll positions
          // because getBoundingClientRect gives us the position
          // relative to the viewport, not to the page
          scope.position.top += scrollTop;
          scope.position.left += scrollLeft;

          return this;
        };

        // get current selection and act on toolbar depending on it
        var checkSelection = function (e) {

          // if you click something from the toolbar
          // don't do anything
          if (e && e.target && $toolbar.find(e.target).length) {
            return false;
          }

          var newSelection = window.getSelection();

          // get selection node
          var anchorNode = newSelection.anchorNode;

          // if nothing selected, hide the toolbar
          if (newSelection.toString().trim() === '' || !anchorNode) {
            // hide the toolbar
            return $timeout(function () {
              scope.model.showToolbar = false;
            });
          }

          // check if selection is in the current editor/directive container
          var parentNode = anchorNode.parentNode;
          while (parentNode.tagName !== undefined && parentNode !== element[0]) {
            parentNode = parentNode.parentNode;
          }

          // if the selection is in the current editor
          if (parentNode === element[0]) {
            // show the toolbar
            $timeout(function () {
              scope.model.showToolbar = true;
              setToolbarPosition();
            });

            // check selection styles and active buttons based on it
            checkActiveButtons(newSelection);
          } else {
            // hide the toolbar
            $timeout(function () {
              scope.model.showToolbar = false;
            });
          }

          return this;
        };

        // check current selection styles and activate buttons
        var checkActiveButtons = function (selection) {
          var parentNode = selection.anchorNode;

          if (!parentNode.tagName) {
            parentNode = selection.anchorNode.parentNode;
          }

          var childNode = parentNode.childNodes[0];

          if (childNode && childNode.tagName && childNode.tagName.toLowerCase() in generatedTags) {
            parentNode = parentNode.childNodes[0];
          }

          $timeout(function () {
            // get real styles of selected element
            scope.styles = window.getComputedStyle(parentNode, null);

            if (scope.styles.fontSize !== scope.size.label + 'px') {
              // set font size selector
              angular.forEach(scope.sizeOptions, function (size, i) {
                if (scope.styles.fontSize === (size.label + 'px')) {
                  scope.size = scope.sizeOptions[i].value;
                  return false;
                }
              });
            }

          });

        };

        // check selection when selecting with the shift key
        $content.bind('keyup', checkSelection);

        // check the selection on every mouseup
        // it also triggeres when releasing outside the browser

        // use debounce to fix issue with Chrome
        // getting the right selection only after a delay
        // if selecting text, then single-clicking the selected text
        document.addEventListener('mouseup', debounce(checkSelection, 200));

        $content.bind('blur', debounce(checkSelection, 200));

        // if after a selection in the select,
        // the contenteditable doesn't get the focus
        // the toolbar will not hide on blur.
        // so I have to add a blur event to the selects.
        $selects.bind('blur', debounce(checkSelection, 200));

        // simple edit action - bold, italic, underline
        scope.SimpleAction = function (action, tag) {
          if (!tag) tag = null;
          document.execCommand('styleWithCSS', false, false);
          document.execCommand(action, false, tag);

          // custom event for two-way binding
          scope.$broadcast('meditor-change');
        };

        // watch the font size selector
        scope.$watch('size', function () {
          document.execCommand('styleWithCSS', false, false);
          document.execCommand('fontSize', false, scope.size);

          // custom event for two-way binding
          scope.$broadcast('meditor-change');
        });

        // watch the font family selector
        scope.$watch('family', function () {
          // dynamically load the family from google fonts
          if (window.WebFont) {
            WebFont.load({
              google: {
                families: [scope.family.label]
              }
            });
          }

          document.execCommand('styleWithCSS', false, true);
          document.execCommand('fontName', false, scope.family.value);

          // custom event for two-way binding
          scope.$broadcast('meditor-change');
        });

        // load google webfont library
        // to be able to dynamically load fonts
        (function () {
          var wf = document.createElement('script');
          wf.src = ('https:' === document.location.protocol ? 'https' : 'http') +
            '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
          wf.type = 'text/javascript';
          wf.async = 'true';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(wf, s);
        })();

        // move the toolbar to the body, we can use overflow: hidden on containers
        $body.append($toolbar);

      }
    };
  }])
  .directive('meditorContenteditable', ['$timeout', function ($timeout) {
    'use strict';

    return {
      require: '?ngModel',
      link: function (scope, elm, attrs, ctrl) {

        // don't throw an error without ng-model
        if (typeof scope.ngModel !== 'undefined') {

          var change = function () {
            $timeout(function () {
              ctrl.$setViewValue(elm.html());
            });
          };

          // custom event to change the ngModel after using
          // actions from the editor
          scope.$on('meditor-change', change);

          elm.on('blur keyup', change);

          ctrl.$render = function () {
            elm.html(ctrl.$viewValue);
          };

          ctrl.$setViewValue(scope.ngModel);
          elm.html(ctrl.$viewValue);

          scope.$watch('ngModel', function (ngModel) {
            // change the html only if it's different from the model
            // eg. on outside changes
            // so we don't lose the selection when editing with the
            // editor toolbar
            if (elm.html() !== ngModel) {
              elm.html(ngModel);
            }
          });

        }

      }
    };
  }])
  .directive('insertForm', ['$document', '$compile', function ($document, $compile) {
    return {
      require: '?ngModel',
      restrict: 'A',
      scope: {
        insertLink: "="
      },
      link: function ($scope, elem, attrs, ngModel) {
        function guid() {
          function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
              .toString(16)
              .substring(1);
          }
          return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
            s4() + '-' + s4() + s4() + s4();
        }
        $scope.inputId = guid();
        $scope.insertData = 'https://blog.optimizely.com/wp-content/uploads/2013/06/Screen-Shot-2013-06-11-at-6.27.42-PM.png';
        var
          template =
            '<div class="colorpicker f-dropdown">' +
            '<input ng-model="insertData" id="{{ inputId }}" />' +
            '<button class="tiny secondary button right" ng-click="SimpleAction()">Insert</button>' +
            '</div>',
          colorpickerTemplate = angular.element(template),
          fixedPosition = angular.isDefined(attrs.colorpickerFixedPosition) ? attrs.colorpickerFixedPosition : false,
          target = angular.isDefined(attrs.colorpickerParent) ? elem.parent() : angular.element(document.body);

        $compile(colorpickerTemplate)($scope);

        function handlePaste(e) {
          var clipboardData, pastedData;

          // Stop data actually being pasted into div
          e.stopPropagation();
          e.preventDefault();

          // Get pasted data via clipboard API
          clipboardData = e.clipboardData || window.clipboardData;
          pastedData = clipboardData.getData('Text');

          // Do whatever with pasteddata
          $scope.$applyAsync(function () {
            $scope.insertData = pastedData;
          });
        }

        window.addEventListener('paste', handlePaste);

        var input = document.getElementById($scope.inputId);

        function appendCharacter(c) {
          $scope.$applyAsync(function () {
            switch (c) {
              case 8: // Backspace
                $scope.insertData = $scope.insertData.slice(0, -1);
                break;
              default:
                $scope.insertData = $scope.insertData + String.fromCharCode(c);
            }
          })

        }

        // Keypress gets the keyCode of the current character not key.
        // e.g. pressing the 'A' key will result in 'a' unless 'Shift' is also held.
        window.addEventListener('keypress', function (e) {
          console.log(e.charCode);
          console.log(e.keyCode);
          appendCharacter(e.keyCode);
        });

        // Use Keydown to get special keys like Backspace, Enter, Esc.
        window.addEventListener('keydown', function (e) {
          switch (e.keyCode) {
            case 8: // Backspace
              e.preventDefault(); // Stops the backspace key from acting like the back button.
              appendCharacter(e.keyCode);
              break;
          }
        });

        var bindMouseEvents = function () {
          $document.on('mousemove', mousemove);
          $document.on('mouseup', mouseup);
        };

        $scope.SimpleAction = function () {
          var action = 'insertImage',
            tag = $scope.insertData;
          if (!$scope.insertLink) {
            action = 'insertImage';
          } else {
            action = 'createLink'
          }
          document.execCommand('styleWithCSS', false, false);
          document.execCommand(action, false, tag);

          // custom event for two-way binding
          $scope.$broadcast('meditor-change');
        };

        /*if (fixedPosition) {
          colorpickerTemplate.addClass('colorpicker-fixed-position');
        }*/

        target.append(colorpickerTemplate);

        if (ngModel) {
          ngModel.$render = function () {
            elem.val(ngModel.$viewValue);
          };
          $scope.$watch(attrs.ngModel, function () {
            update();
          });
        }

        elem.on('$destroy', function () {
          colorpickerTemplate.remove();
        });

        var mouseup = function () {
          $document.off('mousemove', mousemove);
          $document.off('mouseup', mouseup);
        };

        var getColorpickerTemplatePosition = function () {
          var
            positionValue,
            positionOffset = function (elem) {
              var
                x = 0,
                y = 0;
              while (elem && !isNaN(elem.offsetLeft) && !isNaN(elem.offsetTop)) {
                x += elem.offsetLeft;
                y += elem.offsetTop;
                elem = elem.offsetParent;
              }
              return {
                top: y,
                left: x
              };
            }(elem[0]);

          positionValue = {
            'top': positionOffset.top + elem[0].offsetHeight,
            'left': positionOffset.left
          };

          return {
            'top': positionValue.top + 'px',
            'left': positionValue.left + 'px'
          };
        };

        elem.on('click', function () {
          colorpickerTemplate
            .addClass('colorpicker-visible')
            .css(getColorpickerTemplatePosition());
        });

        colorpickerTemplate.on('mousedown', function (event) {
          event.stopPropagation();
          event.preventDefault();
        });

        var hideColorpickerTemplate = function () {
          if (colorpickerTemplate.hasClass('colorpicker-visible')) {
            colorpickerTemplate.removeClass('colorpicker-visible');
          }
        };

        colorpickerTemplate.find('button').on('click', function () {
          hideColorpickerTemplate();
        });

        $document.on('mousedown', function () {
          hideColorpickerTemplate();
        });
      }
    };
  }])
"use strict";function cancelEvent(a){return a=a||window.event,a&&(a=a.originalEvent||a,a.stopPropagation&&a.stopPropagation(),a.preventDefault&&a.preventDefault()),!1}var emojiApp=angular.module("emojiApp",["ngSanitize","angular-meditor"]);emojiApp.config(["$sceProvider",function(a){a.enabled(!1);var b,c,d,e,f,g,h,i={},j={};for(c=0;c<Config.EmojiCategories.length;c++)for(h=Config.EmojiCategorySpritesheetDimens[c][1],b=0;b<Config.EmojiCategories[c].length;b++)e=Config.Emoji[Config.EmojiCategories[c][b]],d=e[1][0],f=Math.floor(b/h),g=b%h,i[":"+d+":"]=[c,f,g,":"+d+":"],j[d]=e[0];$.emojiarea.spritesheetPath="img/emojisprite_!.png",$.emojiarea.spritesheetDimens=Config.EmojiCategorySpritesheetDimens,$.emojiarea.iconSize=20,$.emojiarea.icons=i,$.emojiarea.reverseIcons=j}]),emojiApp.directive("contenteditable",["$sce",function(a){return{restrict:"A",require:"?ngModel",link:function(a,b,c,d){function e(){var a=b.html();c.stripBr&&"<br>"==a&&(a=""),d.$setViewValue(a)}d&&(d.$render=function(){b.html(d.$viewValue||"")},b.on("blur keyup change",function(){a.$evalAsync(e)}),e())}}}]),emojiApp.directive("emojiForm",["$timeout","$http","$interpolate","$compile",function(a,b,c,d){function e(b,e,f){function g(){}function h(){q&&($(q).trigger("change"),i())}function i(){var a=q.offsetHeight;u!=a&&(u=a,b.$emit("ui_editor_resize"))}function j(a){var c=(a.originalEvent||a).target,d=(c||{}).src||"";if("data:"==d.substr(0,5)){!0;var e=dataUrlToBlob(d);ErrorService.confirm({type:"FILE_CLIPBOARD_PASTE"}).then(function(){b.draftMessage.files=[e],b.draftMessage.isMedia=!0}),setZeroTimeout(function(){c.parentNode.removeChild(c)})}else if(d&&!d.match(/img\/blank\.gif/)){var f=document.createTextNode(" "+d+" ");setTimeout(function(){c.parentNode.replaceChild(f,c)},100)}}function k(a){console.log("onPasteEvent");var c,d,e=(a.originalEvent||a).clipboardData,f=e&&e.items||[],g=[];for(d=0;d<f.length;d++)"file"==f[d].kind&&(c=f[d].getAsFile(),g.push(c));g.length>0&&ErrorService.confirm({type:"FILES_CLIPBOARD_PASTE",files:g}).then(function(){b.draftMessage.files=g,b.draftMessage.isMedia=!0})}function l(a){if(!(9!=a.keyCode||a.shiftKey||a.ctrlKey||a.metaKey||$modalStack.getTop()))return p.focus(),cancelEvent(a)}var m=$("textarea",e)[0],n=$("input",e),o=$("#emojibtn",e)[0],p=m;$(m).emojiarea({button:o,norealTime:!0}),$(".emoji-menu",e)[0];b.emojiWysiwig||$(".emoji-wysiwyg-editor",e).removeAttr("meditor");var q=$(".emoji-wysiwyg-editor",e)[0],r=d($("#messageDiv"));if($("#messageDiv").replaceWith(r(b)),q){p=q,$(q).addClass("form-control"),$(m).attr("placeholder")&&$(q).attr("placeholder",c($(m).attr("placeholder"))(b));var s;$(q).on("DOMNodeInserted",j).on("keyup",function(c){i(),v||b.$apply(function(){b.emojiMessage.messagetext=q.textContent}),a.cancel(s),s=a(h,1e3)})}var t=!0;$(p).on("keydown",function(c){if(q&&i(),13==c.keyCode){var d=!1;if(t&&!c.shiftKey?d=!0:t||!c.ctrlKey&&!c.metaKey||(d=!0),d)return a.cancel(s),h(),b.emojiMessage.replyToUser(),g(),cancelEvent(c)}});var u=q.offsetHeight;$(document).on("keydown",l),$(document).on("paste",k);var v=!1;b.$on("$destroy",function(){$(document).off("paste",k),$(document).off("keydown",l),$(submitBtn).off("mousedown"),n.off("change"),q&&$(q).off("DOMNodeInserted keyup",j),$(p).off("keydown")})}return{scope:{emojiMessage:"=",emojiWysiwig:"="},link:e}}]),emojiApp.directive("contenteditable",["$sce",function(a){return{restrict:"A",require:"?ngModel",link:function(a,b,c,d){function e(){var a=b.html();c.stripBr&&"<br>"==a&&(a=""),d.$setViewValue(a)}d&&(d.$render=function(){b.html(d.$viewValue||"")},b.on("blur keyup change",function(){a.$evalAsync(e)}),e())}}}]),emojiApp.filter("colonToCode",function(){return function(a){return a?(Config.rx_colons||Config.init_unified(),a.replace(Config.rx_colons,function(a){var b=Config.mapcolon[a];return b||""})):""}}),emojiApp.filter("codeToSmiley",function(){return function(a){return a?(Config.rx_codes||Config.init_unified(),a.replace(Config.rx_codes,function(a){var b=Config.reversemap[a];if(b){b=":"+b+":";return $.emojiarea.createIcon($.emojiarea.icons[b])}return""})):""}}),emojiApp.filter("colonToSmiley",function(){return function(a){return a?(Config.rx_colons||Config.init_unified(),a.replace(Config.rx_colons,function(a){if(a){return $.emojiarea.createIcon($.emojiarea.icons[a])}return""})):""}}),function(a){function b(a){h=a}function c(){i=!0}function d(){return i?(i=!1,""):h}function e(){var a,b,c,e=Array.prototype.slice.call(arguments),f=e.pop(),g=[],h=1==e.length,i=!0,m=d();for(b=0;b<e.length;b++)if(c=e[b]=m+e[b],"xt_"!=c.substr(0,3)&&void 0!==j[c])g.push(j[c]);else if(l){try{a=localStorage.getItem(c)}catch(a){l=!1}try{a=void 0!==a&&null!==a&&JSON.parse(a)}catch(b){a=!1}g.push(j[c]=a)}else k?i=!1:g.push(j[c]=!1);if(i)return f(h?g[0]:g);chrome.storage.local.get(e,function(a){var d;for(g=[],b=0;b<e.length;b++)c=e[b],d=a[c],d=void 0!==d&&null!==d&&JSON.parse(d),g.push(j[c]=d);f(h?g[0]:g)})}function f(a,b){var c,e,f={},g=d();for(c in a)if(a.hasOwnProperty(c))if(e=a[c],c=g+c,j[c]=e,e=JSON.stringify(e),l)try{localStorage.setItem(c,e)}catch(a){l=!1}else f[c]=e;if(l||!k)return void(b&&b());chrome.storage.local.set(f,b)}function g(){var a,b,c,e=Array.prototype.slice.call(arguments),f=d();for("function"==typeof e[e.length-1]&&(c=e.pop()),a=0;a<e.length;a++)if(b=e[a]=f+e[a],delete j[b],l)try{localStorage.removeItem(b)}catch(a){l=!1}k?chrome.storage.local.remove(e,c):c&&c()}var h="",i=!1,j={},k=!!(a.chrome&&chrome.storage&&chrome.storage.local),l=!k&&!!a.localStorage;a.ConfigStorage={prefix:b,noPrefix:c,get:e,set:f,remove:g}}(this),function(a,b,c){var d=1,e=3,f=["p","div","pre","form"],g=27,h=9;a.emojiarea={path:"",spritesheetPath:"",spritesheetDimens:[],iconSize:20,icons:{},defaults:{button:null,buttonLabel:"Emojis",buttonPosition:"after"}};var i=":joy:,:kissing_heart:,:heart:,:heart_eyes:,:blush:,:grin:,:+1:,:relaxed:,:pensive:,:smile:,:sob:,:kiss:,:unamused:,:flushed:,:stuck_out_tongue_winking_eye:,:see_no_evil:,:wink:,:smiley:,:cry:,:stuck_out_tongue_closed_eyes:,:scream:,:rage:,:smirk:,:disappointed:,:sweat_smile:,:kissing_closed_eyes:,:speak_no_evil:,:relieved:,:grinning:,:yum:,:laughing:,:ok_hand:,:neutral_face:,:confused:".split(",");a.fn.emojiarea=function(b){return b=a.extend({},a.emojiarea.defaults,b),this.each(function(){var d=a(this);"contentEditable"in c.body&&!1!==b.wysiwyg?new m(d,b):new l(d,b)})};var j={};j.restoreSelection=function(){return b.getSelection?function(a){var c=b.getSelection();c.removeAllRanges();for(var d=0,e=a.length;d<e;++d)c.addRange(a[d])}:c.selection&&c.selection.createRange?function(a){a&&a.select()}:void 0}(),j.saveSelection=function(){return b.getSelection?function(){var a=b.getSelection(),c=[];if(a.rangeCount)for(var d=0,e=a.rangeCount;d<e;++d)c.push(a.getRangeAt(d));return c}:c.selection&&c.selection.createRange?function(){var a=c.selection;return"none"!==a.type.toLowerCase()?a.createRange():null}:void 0}(),j.replaceSelection=function(){return b.getSelection?function(a){var d,e=b.getSelection(),f="string"==typeof a?c.createTextNode(a):a;e.getRangeAt&&e.rangeCount&&(d=e.getRangeAt(0),d.deleteContents(),d.insertNode(c.createTextNode(" ")),d.insertNode(f),d.setStart(f,0),b.setTimeout(function(){d=c.createRange(),d.setStartAfter(f),d.collapse(!0),e.removeAllRanges(),e.addRange(d)},0))}:c.selection&&c.selection.createRange?function(a){var b=c.selection.createRange();"string"==typeof a?b.text=a:b.pasteHTML(a.outerHTML)}:void 0}(),j.insertAtCursor=function(a,b){a=" "+a;var d,e,f=b.value;void 0!==b.selectionStart&&void 0!==b.selectionEnd?(d=b.selectionStart,b.selectionEnd,b.value=f.substring(0,d)+a+f.substring(b.selectionEnd),b.selectionStart=b.selectionEnd=d+a.length):void 0!==c.selection&&void 0!==c.selection.createRange&&(b.focus(),e=c.selection.createRange(),e.text=a,e.select())},j.extend=function(a,b){if(void 0!==a&&a||(a={}),"object"==typeof b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a},j.escapeRegex=function(a){return(a+"").replace(/([.?*+^$[\]\\(){}|-])/g,"\\$1")},j.htmlEntities=function(a){return String(a).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;")},j.emojiInserted=function(a,b){ConfigStorage.get("emojis_recent",function(b){b=b||i||[];var c=b.indexOf(a);if(!c)return!1;-1!=c&&b.splice(c,1),b.unshift(a),b.length>42&&(b=b.slice(42)),ConfigStorage.set({emojis_recent:b})})};var k=function(){};k.prototype.setup=function(){var a=this;this.$editor.on("focus",function(){a.hasFocus=!0}),this.$editor.on("blur",function(){a.hasFocus=!1}),this.setupButton()},k.prototype.setupButton=function(){var b,c=this;this.options.button?b=a(this.options.button):!1!==this.options.button?(b=a('<a href="javascript:void(0)">'),b.html(this.options.buttonLabel),b.addClass("emoji-button"),b.attr({title:this.options.buttonLabel}),this.$editor[this.options.buttonPosition](b)):b=a(""),b.on("click",function(a){n.show(c),a.stopPropagation()}),this.$button=b},k.createIcon=function(b,c){var d=b[0],e=b[1],f=b[2],g=b[3],h=a.emojiarea.spritesheetPath,i=c&&Config.Mobile?26:a.emojiarea.iconSize,k=-i*f,l=-i*e,m=a.emojiarea.spritesheetDimens[d][1]*i,n=a.emojiarea.spritesheetDimens[d][0]*i,o="display:inline-block;";return o+="width:"+i+"px;",o+="height:"+i+"px;",o+="background:url('"+h.replace("!",d)+"') "+k+"px "+l+"px no-repeat;",'<img src="img/blank.gif" class="img" style="'+(o+="background-size:"+m+"px "+n+"px;")+'" alt="'+j.htmlEntities(g)+'">'},a.emojiarea.createIcon=k.createIcon;var l=function(a,b){this.options=b,this.$textarea=a,this.$editor=a,this.setup()};l.prototype.insert=function(b){a.emojiarea.icons.hasOwnProperty(b)&&(j.insertAtCursor(b,this.$textarea[0]),j.emojiInserted(b,this.menu),this.$textarea.trigger("change"))},l.prototype.val=function(){return this.$textarea.val()},j.extend(l.prototype,k.prototype);var m=function(b,d){var e=this;this.options=d||{},this.$textarea=b,this.$editor=a("<div>").addClass("emoji-wysiwyg-editor"),this.$editor.text(b.val()),this.$editor.attr({contenteditable:"true",id:"messageDiv","ng-model":"emojiMessage.rawhtml",meditor:"meditor"});var f="blur change";this.options.norealTime||(f+=" keyup"),this.$editor.on(f,function(a){return e.onChange.apply(e,[a])}),this.$editor.on("paste",function(a){return e.onPaste.apply(e,[a])}),this.$editor.on("mousedown focus",function(){c.execCommand("enableObjectResizing",!1,!1)}),this.$editor.on("blur",function(){c.execCommand("enableObjectResizing",!0,!0)});var g=this.$editor.text(),h=a.emojiarea.icons;for(var i in h)h.hasOwnProperty(i)&&(g=g.replace(new RegExp(j.escapeRegex(i),"g"),k.createIcon(h[i])));this.$editor.html(g),b.hide().after(this.$editor),this.setup(),a(c.body).on("mousedown",function(){e.hasFocus&&(e.selection=j.saveSelection())})};m.prototype.onPaste=function(a){var b,d=(a.originalEvent||a).clipboardData,e=d&&d.items||[];for(b=0;b<e.length;b++)if("file"==e[b].kind)return a.preventDefault(),!0;var f=(a.originalEvent||a).clipboardData.getData("text/plain"),g=this;return setTimeout(function(){g.onChange()},0),!f.length||(c.execCommand("insertText",!1,f),cancelEvent(a))},m.prototype.onChange=function(a){this.$textarea.val(this.val()).trigger("change")},m.prototype.insert=function(b){var c=a(k.createIcon(a.emojiarea.icons[b]));c[0].attachEvent&&c[0].attachEvent("onresizestart",function(a){a.returnValue=!1},!1),this.$editor.trigger("focus"),this.selection&&j.restoreSelection(this.selection);try{j.replaceSelection(c[0])}catch(a){}j.emojiInserted(b,this.menu),this.onChange()},m.prototype.val=function(){for(var a=[],b=[],c=function(){a.push(b.join("")),b=[]},g=function(a){if(a.nodeType===e)b.push(a.nodeValue);else if(a.nodeType===d){var h=a.tagName.toLowerCase(),i=-1!==f.indexOf(h);if(i&&b.length&&c(),"img"===h){var j=a.getAttribute("alt")||"";return void(j&&b.push(j))}"br"===h&&c();for(var k=a.childNodes,l=0;l<k.length;l++)g(k[l]);i&&b.length&&c()}},h=this.$editor[0].childNodes,i=0;i<h.length;i++)g(h[i]);return b.length&&c(),a.join("\n")},j.extend(m.prototype,k.prototype);var n=function(){var d=this,e=a(c.body),f=a(b);this.visible=!1,this.emojiarea=null,this.$menu=a("<div>"),this.$menu.addClass("emoji-menu"),this.$menu.hide(),this.$itemsTailWrap=a('<div class="emoji-items-wrap1"></div>').appendTo(this.$menu),this.$categoryTabs=a('<table class="emoji-menu-tabs"><tr><td><a class="emoji-menu-tab icon-recent" ></a></td><td><a class="emoji-menu-tab icon-smile" ></a></td><td><a class="emoji-menu-tab icon-flower"></a></td><td><a class="emoji-menu-tab icon-bell"></a></td><td><a class="emoji-menu-tab icon-car"></a></td><td><a class="emoji-menu-tab icon-grid"></a></td></tr></table>').appendTo(this.$itemsTailWrap),this.$itemsWrap=a('<div class="emoji-items-wrap nano mobile_scrollable_wrap"></div>').appendTo(this.$itemsTailWrap),this.$items=a('<div class="emoji-items nano-content">').appendTo(this.$itemsWrap),e.append(this.$menu),Config.Mobile||this.$itemsWrap.nanoScroller({preventPageScrolling:!0,tabIndex:-1}),e.on("keydown",function(a){a.keyCode!==g&&a.keyCode!==h||d.hide()}),e.on("message_send",function(a){d.hide()}),e.on("mouseup",function(a){a=a.originalEvent||a;for(var c=a.originalTarget||a.target||b;c&&c!=b;)if((c=c.parentNode)==d.$menu[0]||d.emojiarea&&c==d.emojiarea.$button[0])return;d.hide()}),f.on("resize",function(){d.visible&&d.reposition()}),this.$menu.on("mouseup","a",function(a){return a.stopPropagation(),!1}),this.$menu.on("click","a",function(c){if(a(this).hasClass("emoji-menu-tab"))return d.getTabIndex(this)!==d.currentCategory&&d.selectCategory(d.getTabIndex(this)),!1;var e=a(".label",a(this)).text();return b.setTimeout(function(){d.onItemSelected(e),(c.ctrlKey||c.metaKey)&&d.hide()},0),c.stopPropagation(),!1}),this.selectCategory(0)};n.prototype.getTabIndex=function(a){return this.$categoryTabs.find(".emoji-menu-tab").index(a)},n.prototype.selectCategory=function(a){this.$categoryTabs.find(".emoji-menu-tab").each(function(b){b===a?this.className+="-selected":this.className=this.className.replace("-selected","")}),this.currentCategory=a,this.load(a),Config.Mobile||this.$itemsWrap.nanoScroller({scroll:"top"})},n.prototype.onItemSelected=function(a){this.emojiarea.insert(a)},n.prototype.load=function(b){var c=[],d=a.emojiarea.icons,e=a.emojiarea.path,f=this;e.length&&"/"!==e.charAt(e.length-1)&&(e+="/");var g=function(){f.$items.html(c.join("")),Config.Mobile||setTimeout(function(){f.$itemsWrap.nanoScroller()},100)};if(b>0){for(var h in d)d.hasOwnProperty(h)&&d[h][0]===b-1&&c.push('<a href="javascript:void(0)" title="'+j.htmlEntities(h)+'">'+k.createIcon(d[h],!0)+'<span class="label">'+j.htmlEntities(h)+"</span></a>");g()}else ConfigStorage.get("emojis_recent",function(a){a=a||i||[];var b,e;for(e=0;e<a.length;e++)b=a[e],d[b]&&c.push('<a href="javascript:void(0)" title="'+j.htmlEntities(b)+'">'+k.createIcon(d[b],!0)+'<span class="label">'+j.htmlEntities(b)+"</span></a>");g()})},n.prototype.reposition=function(){var a=this.emojiarea.$button,b=a.offset();b.top+=a.outerHeight(),b.left+=Math.round(a.outerWidth()/2),this.$menu.css({top:b.top,left:b.left})},n.prototype.hide=function(a){this.emojiarea&&(this.emojiarea.menu=null,this.emojiarea.$button.removeClass("on"),this.emojiarea=null),this.visible=!1,this.$menu.hide("fast")},n.prototype.show=function(a){if(this.emojiarea&&this.emojiarea===a)return this.hide();a.$button.addClass("on"),this.emojiarea=a,this.emojiarea.menu=this,this.reposition(),this.$menu.show("fast"),this.currentCategory||this.load(0),this.visible=!0},n.show=function(){var a=null;return function(b){a=a||new n,a.show(b)}}()}(jQuery,window,document),function(a,b,c){var d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E;w={paneClass:"nano-pane",sliderClass:"nano-slider",contentClass:"nano-content",iOSNativeScrolling:!1,preventPageScrolling:!1,disableResize:!1,alwaysVisible:!1,flashDelay:1500,sliderMinHeight:20,sliderMaxHeight:null,documentContext:null,windowContext:null},r="scroll",j="mousedown",k="mouseenter",l="mousemove",n="mousewheel",m="mouseup",q="resize",h="drag",i="enter",t="up",p="panedown",f="DOMMouseScroll",g="down",u="wheel",s="touchmove",d="Microsoft Internet Explorer"===b.navigator.appName&&/msie 7./i.test(b.navigator.appVersion)&&b.ActiveXObject,e=null,A=b.requestAnimationFrame,v=b.cancelAnimationFrame,C=c.createElement("div").style,E=function(){var a,b,c,d;for(b=["t","webkitT","MozT","msT","OT"],a=c=0,d=b.length;c<d;a=++c)if(b[a],b[a]+"ransform"in C)return b[a].substr(0,b[a].length-1);return!1}(),D=function(a){return!1!==E&&(""===E?a:E+a.charAt(0).toUpperCase()+a.substr(1))},B=D("transform"),y=!1!==B,x=function(){var a,b,d;return a=c.createElement("div"),b=a.style,b.position="absolute",b.width="100px",b.height="100px",b.overflow=r,b.top="-9999px",c.body.appendChild(a),d=a.offsetWidth-a.clientWidth,c.body.removeChild(a),d},z=function(){var a,c,d;return c=b.navigator.userAgent,!!(a=/(?=.+Mac OS X)(?=.+Firefox)/.test(c))&&(d=/Firefox\/\d{2}\./.exec(c),d&&(d=d[0].replace(/\D+/g,"")),a&&+d>23)},o=function(){function o(d,f){this.el=d,this.options=f,e||(e=x()),this.$el=a(this.el),this.doc=a(this.options.documentContext||c),this.win=a(this.options.windowContext||b),this.body=this.doc.find("body"),this.$content=this.$el.children("."+f.contentClass),this.$content.attr("tabindex",this.options.tabIndex||0),this.content=this.$content[0],this.previousPosition=0,this.options.iOSNativeScrolling&&(null!=this.el.style.WebkitOverflowScrolling||navigator.userAgent.match(/mobi.+Gecko/i))?this.nativeScrolling():this.generate(),this.createEvents(),this.addEvents(),this.reset()}return o.prototype.preventScrolling=function(a,b){if(this.isActive)if(a.type===f)(b===g&&a.originalEvent.detail>0||b===t&&a.originalEvent.detail<0)&&a.preventDefault();else if(a.type===n){if(!a.originalEvent||!a.originalEvent.wheelDelta)return;(b===g&&a.originalEvent.wheelDelta<0||b===t&&a.originalEvent.wheelDelta>0)&&a.preventDefault()}},o.prototype.nativeScrolling=function(){this.$content.css({WebkitOverflowScrolling:"touch"}),this.iOSNativeScrolling=!0,this.isActive=!0},o.prototype.updateScrollValues=function(){var a,b;a=this.content,this.maxScrollTop=a.scrollHeight-a.clientHeight,this.prevScrollTop=this.contentScrollTop||0,this.contentScrollTop=a.scrollTop,b=this.contentScrollTop>this.previousPosition?"down":this.contentScrollTop<this.previousPosition?"up":"same",this.previousPosition=this.contentScrollTop,"same"!==b&&this.$el.trigger("update",{position:this.contentScrollTop,maximum:this.maxScrollTop,direction:b}),this.iOSNativeScrolling||(this.maxSliderTop=this.paneHeight-this.sliderHeight,this.sliderTop=0===this.maxScrollTop?0:this.contentScrollTop*this.maxSliderTop/this.maxScrollTop)},o.prototype.setOnScrollStyles=function(){var a;y?(a={},a[B]="translate(0, "+this.sliderTop+"px)"):a={top:this.sliderTop},A?(v&&this.scrollRAF&&v(this.scrollRAF),this.scrollRAF=A(function(b){return function(){return b.scrollRAF=null,b.slider.css(a)}}(this))):this.slider.css(a)},o.prototype.createEvents=function(){this.events={down:function(a){return function(b){return a.isBeingDragged=!0,a.offsetY=b.pageY-a.slider.offset().top,a.slider.is(b.target)||(a.offsetY=0),a.pane.addClass("active"),a.doc.bind(l,a.events[h]).bind(m,a.events[t]),a.body.bind(k,a.events[i]),!1}}(this),drag:function(a){return function(b){return a.sliderY=b.pageY-a.$el.offset().top-a.paneTop-(a.offsetY||.5*a.sliderHeight),a.scroll(),a.contentScrollTop>=a.maxScrollTop&&a.prevScrollTop!==a.maxScrollTop?a.$el.trigger("scrollend"):0===a.contentScrollTop&&0!==a.prevScrollTop&&a.$el.trigger("scrolltop"),!1}}(this),up:function(a){return function(b){return a.isBeingDragged=!1,a.pane.removeClass("active"),a.doc.unbind(l,a.events[h]).unbind(m,a.events[t]),a.body.unbind(k,a.events[i]),!1}}(this),resize:function(a){return function(b){a.reset()}}(this),panedown:function(a){return function(b){return a.sliderY=(b.offsetY||b.originalEvent.layerY)-.5*a.sliderHeight,a.scroll(),a.events.down(b),!1}}(this),scroll:function(a){return function(b){a.updateScrollValues(),a.isBeingDragged||(a.iOSNativeScrolling||(a.sliderY=a.sliderTop,a.setOnScrollStyles()),null!=b&&(a.contentScrollTop>=a.maxScrollTop?(a.options.preventPageScrolling&&a.preventScrolling(b,g),a.prevScrollTop!==a.maxScrollTop&&a.$el.trigger("scrollend")):0===a.contentScrollTop&&(a.options.preventPageScrolling&&a.preventScrolling(b,t),0!==a.prevScrollTop&&a.$el.trigger("scrolltop"))))}}(this),wheel:function(a){return function(b){var c;if(null!=b)return c=b.delta||b.wheelDelta||b.originalEvent&&b.originalEvent.wheelDelta||-b.detail||b.originalEvent&&-b.originalEvent.detail,c&&(a.sliderY+=-c/3),a.scroll(),!1}}(this),enter:function(a){return function(b){var c;if(a.isBeingDragged)return 1!==(b.buttons||b.which)?(c=a.events)[t].apply(c,arguments):void 0}}(this)}},o.prototype.addEvents=function(){var a;this.removeEvents(),a=this.events,this.options.disableResize||this.win.bind(q,a[q]),this.iOSNativeScrolling||(this.slider.bind(j,a[g]),this.pane.bind(j,a[p]).bind(n+" "+f,a[u])),this.$content.bind(r+" "+n+" "+f+" "+s,a[r])},o.prototype.removeEvents=function(){var a;a=this.events,this.win.unbind(q,a[q]),this.iOSNativeScrolling||(this.slider.unbind(),this.pane.unbind()),this.$content.unbind(r+" "+n+" "+f+" "+s,a[r])},o.prototype.generate=function(){var a,c,d,f,g,h;return d=this.options,g=d.paneClass,h=d.sliderClass,d.contentClass,(f=this.$el.children("."+g)).length||f.children("."+h).length||this.$el.append('<div class="'+g+'"><div class="'+h+'" /></div>'),this.pane=this.$el.children("."+g),this.slider=this.pane.find("."+h),0===e&&z()?(c=b.getComputedStyle(this.content,null).getPropertyValue("padding-right").replace(/[^0-9.]+/g,""),a={right:-14,paddingRight:+c+14}):e&&(a={right:-e},this.$el.addClass("has-scrollbar")),null!=a&&this.$content.css(a),this},o.prototype.restore=function(){this.stopped=!1,this.iOSNativeScrolling||this.pane.show(),this.addEvents()},o.prototype.reset=function(){var a,b,c,f,g,h,i,j,k,l,m,n;return this.iOSNativeScrolling?void(this.contentHeight=this.content.scrollHeight):(this.$el.find("."+this.options.paneClass).length||this.generate().stop(),this.stopped&&this.restore(),a=this.content,f=a.style,g=f.overflowY,d&&this.$content.css({height:this.$content.height()}),b=a.scrollHeight+e,l=parseInt(this.$el.css("max-height"),10),l>0&&(this.$el.height(""),this.$el.height(a.scrollHeight>l?l:a.scrollHeight)),i=this.pane.outerHeight(!1),k=parseInt(this.pane.css("top"),10),h=parseInt(this.pane.css("bottom"),10),j=i+k+h,n=Math.round(j/b*j),n<this.options.sliderMinHeight?n=this.options.sliderMinHeight:null!=this.options.sliderMaxHeight&&n>this.options.sliderMaxHeight&&(n=this.options.sliderMaxHeight),g===r&&f.overflowX!==r&&(n+=e),this.maxSliderTop=j-n,this.contentHeight=b,this.paneHeight=i,this.paneOuterHeight=j,this.sliderHeight=n,this.paneTop=k,this.slider.height(n),this.events.scroll(),this.pane.show(),this.isActive=!0,a.scrollHeight===a.clientHeight||this.pane.outerHeight(!0)>=a.scrollHeight&&g!==r?(this.pane.hide(),this.isActive=!1):this.el.clientHeight===a.scrollHeight&&g===r?this.slider.hide():this.slider.show(),this.pane.css({opacity:this.options.alwaysVisible?1:"",visibility:this.options.alwaysVisible?"visible":""}),c=this.$content.css("position"),"static"!==c&&"relative"!==c||(m=parseInt(this.$content.css("right"),10))&&this.$content.css({right:"",marginRight:m}),this)},o.prototype.scroll=function(){if(this.isActive)return this.sliderY=Math.max(0,this.sliderY),this.sliderY=Math.min(this.maxSliderTop,this.sliderY),this.$content.scrollTop(this.maxScrollTop*this.sliderY/this.maxSliderTop),this.iOSNativeScrolling||(this.updateScrollValues(),this.setOnScrollStyles()),this},o.prototype.scrollBottom=function(a){if(this.isActive)return this.$content.scrollTop(this.contentHeight-this.$content.height()-a).trigger(n),this.stop().restore(),this},o.prototype.scrollTop=function(a){if(this.isActive)return this.$content.scrollTop(+a).trigger(n),this.stop().restore(),this},o.prototype.scrollTo=function(a){if(this.isActive)return this.scrollTop(this.$el.find(a).get(0).offsetTop),this},o.prototype.stop=function(){return v&&this.scrollRAF&&(v(this.scrollRAF),this.scrollRAF=null),this.stopped=!0,this.removeEvents(),this.iOSNativeScrolling||this.pane.hide(),this},o.prototype.destroy=function(){return this.stopped||this.stop(),!this.iOSNativeScrolling&&this.pane.length&&this.pane.remove(),d&&this.$content.height(""),this.$content.removeAttr("tabindex"),this.$el.hasClass("has-scrollbar")&&(this.$el.removeClass("has-scrollbar"),this.$content.css({right:""})),this},o.prototype.flash=function(){if(!this.iOSNativeScrolling&&this.isActive)return this.reset(),this.pane.addClass("flashed"),setTimeout(function(a){return function(){a.pane.removeClass("flashed")}}(this),this.options.flashDelay),this},o}(),a.fn.nanoScroller=function(b){return this.each(function(){var c,d;if((d=this.nanoscroller)||(c=a.extend({},w,b),this.nanoscroller=d=new o(this,c)),b&&"object"==typeof b){if(a.extend(d.options,b),null!=b.scrollBottom)return d.scrollBottom(b.scrollBottom);if(null!=b.scrollTop)return d.scrollTop(b.scrollTop);if(b.scrollTo)return d.scrollTo(b.scrollTo);if("bottom"===b.scroll)return d.scrollBottom(0);if("top"===b.scroll)return d.scrollTop(0);if(b.scroll&&b.scroll instanceof a)return d.scrollTo(b.scroll);if(b.stop)return d.stop();if(b.destroy)return d.destroy();if(b.flash)return d.flash()}return d.reset()})},a.fn.nanoScroller.Constructor=o}(jQuery,window,document);